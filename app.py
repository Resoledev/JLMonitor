"""
Complete Flask app for SaleScout with modern design and recently added tracking
"""
from flask import Flask, render_template, jsonify, request
from flask_caching import Cache
import csv
import os
import json
from datetime import datetime, timedelta

app = Flask(__name__)

# Configure caching for better performance
cache = Cache(app, config={
    'CACHE_TYPE': 'simple',
    'CACHE_DEFAULT_TIMEOUT': 60  # Cache for 60 seconds
})

# Price history file paths
PRICE_HISTORY_FILES = {
    'johnlewis': 'price_history.json',  # Updated to match your actual file
    'selfridges': 'selfridges_price_history.json'
}

# Recently added time threshold (hours) - 1 week
RECENTLY_ADDED_HOURS = 168

# Cache for price history (loaded once, not per product)
_price_history_cache = {}

# Cache for recently reduced IDs (lightweight alternative to full price history)
_recently_reduced_cache = None

def load_recently_reduced_ids():
    """Load lightweight recently reduced IDs (generated by monitor)"""
    global _recently_reduced_cache
    if _recently_reduced_cache is not None:
        return _recently_reduced_cache

    # Try state directory first
    filepath = os.path.join('state', 'recently_reduced_ids.json')
    if not os.path.exists(filepath):
        _recently_reduced_cache = set()
        return _recently_reduced_cache

    try:
        with open(filepath, 'r') as f:
            data = json.load(f)
            # Extract just the IDs into a set for fast lookup
            _recently_reduced_cache = {str(item['id']) for item in data}
            print(f"Loaded {len(_recently_reduced_cache)} recently reduced IDs")
            return _recently_reduced_cache
    except Exception as e:
        print(f"Error loading recently reduced IDs: {e}")
        _recently_reduced_cache = set()
        return _recently_reduced_cache

def is_recently_reduced(product_id, retailer):
    """Check if product is recently reduced using lightweight cache"""
    recently_reduced_ids = load_recently_reduced_ids()
    return str(product_id) in recently_reduced_ids

def is_recently_added(timestamp_str):
    """
    Check if product was added within the recently added time threshold
    """
    if not timestamp_str:
        return False

    try:
        # Parse the timestamp from the CSV
        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
        current_time = datetime.now()
        time_diff = current_time - timestamp

        # Check if the product was added within the threshold
        is_recent = time_diff <= timedelta(hours=RECENTLY_ADDED_HOURS)
        
        return is_recent
    except (ValueError, TypeError) as e:
        return False

@cache.memoize(timeout=60)
def read_selfridges_csv(csv_path='salescout_selfridges.csv'):
    """Read Selfridges CSV data with recently reduced detection"""
    products = []
    if not os.path.exists(csv_path):
        return products

    try:
        with open(csv_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for row in reader:
                # Handle CSV fields based on your structure
                product_id = row.get('Product ID', '')
                
                try:
                    current_price = float(row.get('Current Price', 0)) if row.get('Current Price') else 0
                except ValueError:
                    current_price = 0
                    
                try:
                    original_price = float(row.get('Original Price', 0)) if row.get('Original Price') else 0
                except ValueError:
                    original_price = 0

                try:
                    discount = float(row.get('Discount', 0)) if row.get('Discount') else 0
                except ValueError:
                    discount = 0

                product = {
                    'id': product_id,
                    'name': row.get('Product Name', ''),
                    'brand': row.get('brand', ''),
                    'current_price': current_price,
                    'original_price': original_price,
                    'discount': round(discount, 1),
                    'stock_status': row.get('Stock Status', 'Unknown'),
                    'sizes': row.get('Sizes', 'See product page'),
                    'url': row.get('URL', ''),
                    'image': row.get('Image', ''),
                    'category': row.get('Category', 'Selfridges'),
                    'timestamp': row.get('Timestamp', ''),
                    'retailer': 'Selfridges',
                    'recently_reduced': is_recently_reduced(product_id, 'selfridges'),
                    'recently_added': is_recently_added(row.get('Timestamp', ''))
                }

                if product['original_price'] and product['current_price']:
                    product['savings'] = product['original_price'] - product['current_price']
                else:
                    product['savings'] = 0

                products.append(product)
    except Exception as e:
        print(f"Error reading Selfridges CSV: {e}")

    return products

@cache.memoize(timeout=60)
def read_johnlewis_csv(csv_path=os.path.join(os.path.dirname(__file__), 'johnlewisv2.csv')):
    """Read John Lewis CSV data with recently reduced and recently added detection"""
    products = []
    if not os.path.exists(csv_path):
        print(f"CSV not found: {csv_path}")
        return products

    try:
        with open(csv_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            
            for row in reader:
                product_id = row.get('Product ID', '')
                
                # Parse prices safely
                try:
                    current_price = float(row.get('Current Price', 0)) if row.get('Current Price') else 0
                except ValueError:
                    current_price = 0
                
                try:
                    original_price = float(row.get('Original Price', 0)) if row.get('Original Price') else 0
                except ValueError:
                    original_price = 0
                
                try:
                    discount = float(row.get('Discount', 0)) if row.get('Discount') else 0
                except ValueError:
                    discount = 0
                
                timestamp = row.get('Timestamp', '')
                
                # Check recently added status
                recently_added = is_recently_added(timestamp)
                
                product = {
                    'id': product_id,
                    'name': row.get('Product Name', ''),
                    'brand': 'John Lewis',
                    'current_price': current_price,
                    'original_price': original_price,
                    'discount': discount,
                    'stock_status': row.get('Stock Status', 'Unknown'),
                    'sizes': row.get('Sizes', 'See product page'),
                    'url': row.get('URL', ''),
                    'image': row.get('Image', ''),
                    'category': row.get('Category', 'John Lewis'),
                    'timestamp': timestamp,
                    'retailer': 'John Lewis',
                    'recently_reduced': is_recently_reduced(product_id, 'johnlewis'),
                    'recently_added': recently_added
                }

                if product['original_price'] and product['current_price']:
                    product['savings'] = product['original_price'] - product['current_price']
                else:
                    product['savings'] = 0

                products.append(product)
        
        print(f"Loaded {len(products)} products from John Lewis CSV")
        recently_added_count = sum(1 for p in products if p.get('recently_added', False))
        print(f"  Recently added: {recently_added_count} products")
        
    except Exception as e:
        print(f"Error reading John Lewis CSV: {e}")

    return products

@app.route('/')
def home():
    """Modern SaaS homepage"""
    selfridges = read_selfridges_csv()
    johnlewis = read_johnlewis_csv()

    # Calculate live stats for homepage
    jl_stats = {
        'total': len(johnlewis),
        'max_discount': max([p['discount'] for p in johnlewis], default=0),
        'recently_reduced': sum(1 for p in johnlewis if p.get('recently_reduced', False)),
        'recently_added': sum(1 for p in johnlewis if p.get('recently_added', False))
    }

    sf_stats = {
        'total': len(selfridges),
        'max_discount': max([p['discount'] for p in selfridges], default=0),
        'recently_reduced': sum(1 for p in selfridges if p.get('recently_reduced', False)),
        'recently_added': sum(1 for p in selfridges if p.get('recently_added', False))
    }

    return render_template('modern_home.html',
                         johnlewis_stats=jl_stats,
                         selfridges_stats=sf_stats)

@app.route('/<retailer>')
def retailer_page(retailer):
    """Modern retailer pages with filtering and sorting"""
    if retailer not in ['selfridges', 'johnlewis']:
        return "Retailer not found", 404

    # Get query parameters for filtering/sorting
    search_query = request.args.get('search', '').lower()
    sort_by = request.args.get('sort', 'discount')
    category_filter = request.args.get('category', '')
    recently_added_filter = request.args.get('recently_added', '')

    # Load products
    if retailer == 'selfridges':
        products = read_selfridges_csv()
        retailer_name = 'Selfridges'
        color_theme = 'purple'
    else:
        products = read_johnlewis_csv()
        retailer_name = 'John Lewis'
        color_theme = 'green'

    print(f"\n=== {retailer_name} Filter Debug ===")
    print(f"Total products loaded: {len(products)}")
    print(f"Recently added filter: '{recently_added_filter}'")
    
    # Count recently added BEFORE filtering
    recently_added_count_before = sum(1 for p in products if p.get('recently_added', False))
    print(f"Recently added products before filter: {recently_added_count_before}")

    # Apply filters
    if search_query:
        products = [p for p in products if search_query in p['name'].lower()]
        print(f"After search filter: {len(products)} products")

    if category_filter:
        products = [p for p in products if category_filter.lower() in p['category'].lower()]
        print(f"After category filter: {len(products)} products")

    # Recently added filter
    if recently_added_filter == 'true':
        before_count = len(products)
        products = [p for p in products if p.get('recently_added', False)]
        print(f"Recently added filter applied: {before_count} -> {len(products)} products")
        
        # Debug: Show which products passed
        if products:
            print("Recently added products:")
            for p in products[:5]:  # Show first 5
                print(f"  - {p['name'][:50]} (added: {p.get('timestamp', 'N/A')})")

    # Apply sorting
    if sort_by == 'recently_reduced':
        # Sort by recently_reduced first, then by timestamp (most recent first)
        products.sort(key=lambda x: (
            x.get('recently_reduced', False),
            x.get('timestamp', ''),
            x['discount']
        ), reverse=True)
    elif sort_by == 'recently_added':
        # Sort by recently_added first, then by timestamp (most recent first)
        products.sort(key=lambda x: (
            x.get('recently_added', False),
            x.get('timestamp', ''),
            x['discount']
        ), reverse=True)
    elif sort_by == 'net_reduction':
        products.sort(key=lambda x: x.get('savings', 0), reverse=True)
    elif sort_by == 'price':
        products.sort(key=lambda x: x['current_price'] or float('inf'))
    elif sort_by == 'name':
        products.sort(key=lambda x: x['name'])
    else:  # discount
        products.sort(key=lambda x: x['discount'], reverse=True)

    # Calculate stats
    stats = {
        'total_products': len(products),
        'avg_discount': round(sum(p['discount'] for p in products if p['discount'] > 0) / max(1, len([p for p in products if p['discount'] > 0])), 1),
        'max_discount': max([p['discount'] for p in products], default=0),
        'total_savings': sum(p.get('savings', 0) for p in products),
        'recently_reduced_count': sum(1 for p in products if p.get('recently_reduced', False)),
        'recently_added_count': sum(1 for p in products if p.get('recently_added', False)),
        'last_updated': products[0]['timestamp'] if products else 'Never'
    }
    
    print(f"Final stats - Recently added: {stats['recently_added_count']}")
    print(f"=================================\n")

    return render_template('modern_retailer.html',
                         products=products,
                         retailer=retailer_name,
                         retailer_key=retailer,
                         stats=stats,
                         color_theme=color_theme,
                         current_search=request.args.get('search', ''),
                         current_sort=sort_by,
                         current_category=category_filter,
                         current_recently_added=recently_added_filter)

# API endpoints
@app.route('/api/selfridges')
def api_selfridges():
    """Selfridges API endpoint"""
    products = read_selfridges_csv()
    return jsonify({
        'retailer': 'Selfridges',
        'total_products': len(products),
        'products': products
    })

@app.route('/api/johnlewis')
def api_johnlewis():
    """John Lewis API endpoint"""
    products = read_johnlewis_csv()
    return jsonify({
        'retailer': 'John Lewis',
        'total_products': len(products),
        'products': products
    })

@app.route('/api/deals')
def api_deals():
    """Combined deals API"""
    selfridges = read_selfridges_csv()
    johnlewis = read_johnlewis_csv()

    all_products = selfridges + johnlewis
    all_products.sort(key=lambda x: x['discount'], reverse=True)

    return jsonify({
        'total_products': len(all_products),
        'selfridges_count': len(selfridges),
        'johnlewis_count': len(johnlewis),
        'products': all_products
    })


if __name__ == '__main__':
    port = int(os.getenv('PORT', 5001))
    app.run(host='0.0.0.0', port=port, debug=False)
